<%
  def rbs_to_rbi(type)
    if type.end_with?("?")
      "T.nilable(#{rbs_to_rbi(type.delete_suffix("?"))})"
    elsif type.start_with?("Array[")
      "T::Array[#{rbs_to_rbi(type.delete_prefix("Array[").delete_suffix("]"))}]"
    else
      type
    end
  end
%>

module YARP
  class Node
    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(Location) }
    def location; end
  end

  class Location
    sig { params(source: Source, start_offset: Integer, length: Integer).void }
    def initialize(source, start_offset, length); end

    sig { returns(String) }
    def slice; end

    sig { returns(T::Array[Comment]) }
    def comments; end

    sig { params(options: T.untyped).returns(Location) }
    def copy(**options); end

    sig { returns(Integer) }
    def start_offset; end

    sig { returns(Integer) }
    def end_offset; end

    sig { returns(Integer) }
    def start_line; end

    sig { returns(Integer) }
    def end_line; end

    sig { returns(Integer) }
    def start_column; end

    sig { returns(Integer) }
    def end_column; end
  end

  class Comment
    sig { returns(Location) }
    def location; end
  end

  <%- nodes.each do |node| -%>
  <%= "#{node.comment.split("\n").map { |line| line.empty? ? "#" : "# #{line}" }.join("\n  ")}\n  " if node.comment %>class <%= node.name -%> < Node
    <%- node.fields.each do |field| -%>
    sig { returns(<%= rbs_to_rbi(field.rbs_class) %>) }
    attr_reader :<%= field.name %>

    <%- end -%>
    sig { params(<%= (node.fields.map { |field| "#{field.name}: #{rbs_to_rbi(field.rbs_class)}" } + ["location: Location"]).join(", ") %>).void }
    def initialize(<%= (node.fields.map(&:name) + ["location"]).join(", ") %>); end

    sig { params(visitor: Visitor).void }
    def accept(visitor); end
    <%- if node.newline == false -%>

    def set_newline_flag(newline_marked); end
    <%- elsif node.newline.is_a?(String) -%>

    def set_newline_flag(newline_marked); end
    <%- end -%>

    sig { returns(T::Array[T.nilable(Node)]) }
    def child_nodes; end

    sig { returns(T::Array[T.nilable(Node)]) }
    def deconstruct; end

    sig { params(params: T.untyped).returns(<%= node.name %>) }
    def copy(**params); end

    sig { params(keys: T::Array[Symbol]).returns(T::Hash[Symbol, T.nilable(T.any(Node, T::Array[Node], String, Token, T::Array[Token], Location))]) }
    def deconstruct_keys(keys); end
    <%- node.fields.each do |field| -%>
    <%- case field -%>
    <%- when YARP::LocationField -%>
    <%- raise unless field.name.end_with?("_loc") -%>
    <%- next if node.fields.any? { |other| other.name == field.name.delete_suffix("_loc") } -%>

    sig { returns(String) }
    def <%= field.name.delete_suffix("_loc") %>; end
    <%- when YARP::OptionalLocationField -%>
    <%- raise unless field.name.end_with?("_loc") -%>
    <%- next if node.fields.any? { |other| other.name == field.name.delete_suffix("_loc") } -%>

    sig { returns(T.nilable(String)) }
    def <%= field.name.delete_suffix("_loc") %>; end
    <%- when YARP::FlagsField -%>
    <%- flags.find { |flag| flag.name == field.kind }.tap { |flag| raise "Expected to find #{field.kind}" unless flag }.values.each do |value| -%>

    sig { returns(T::Boolean) }
    def <%= value.name.downcase %>?; end
    <%- end -%>
    <%- end -%>
    <%- end -%>

    sig { params(inspector: NodeInspector).returns(String) }
    def inspect(inspector); end
  end

  <%- end -%>

  <%- flags.each do |flag| -%>
    module <%= flag.name %>
      <%- flag.values.each_with_index do |value, index| -%>
        # <%= value.comment %>
        <%= value.name %> = 1 << <%= index %>
        <%= "\n" if value != flag.values.last -%>
      <%- end -%>
    end
  <%- end -%>

  class Visitor < BasicVisitor
    <%- nodes.each do |node| -%>
      # Visit a <%= node.name %> node
      sig { params(node: <%= node.name %>).void }
      def visit_<%= node.human %>(node); end
      <%= "\n" if node != nodes.last -%>
    <%- end -%>
  end

  module DSL
    private

    # Create a new Location object
    sig { params(source: T.nilable(Source), start_offset: Integer, length: Integer).returns(Location) }
    def Location(source, start_offset, length); end

    <%- nodes.each do |node| -%>
      # Create a new <%= node.name %> node
      sig { params(<%= (node.fields.map { |field| "#{field.name}: #{rbs_to_rbi(field.rbs_class)}" } + ["location: Location"]).join(", ") %>).returns(<%= node.name %>) }
      def <%= node.name %>(<%= (node.fields.map(&:name) + ["location"]).join(", ") %>); end
    <%- end -%>
  end
end
